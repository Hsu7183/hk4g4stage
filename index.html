<script type="module">
/* ========= 0. 參數 ========= */
const MULTIPLIER = 200;          // 1 點 = 200 元
const ENTRY      = ['新買', '新賣'];
const EXIT_LONG  = ['平賣', '強制平倉'];
const EXIT_SHORT = ['平買', '強制平倉'];

/* ========= 1. 兩種匯入方式 ========= */
// ➊ 讀剪貼簿
window.pasteClipboardContent = async function () {
  try {
    const txt = await navigator.clipboard.readText();
    analyse(txt);
  } catch (e) {
    alert('讀取剪貼簿失敗：' + e.message);
  }
};
// ➋ 上傳檔案
document.getElementById('fileInput')
        .addEventListener('change', e => {
          const f = e.target.files[0];
          if (!f) return;
          const r = new FileReader();
          r.onload = () => analyse(
            // 用 Big-5 轉碼，.TF 檔就算是 Big-5 也能吃
            new TextDecoder('big5').decode(r.result)
          );
          r.readAsArrayBuffer(f);
        });

/* ========= 2. 主分析程式 ========= */
function analyse(rawText) {
  const rows = rawText.trim().split(/\r?\n/);
  const queue = [];      // 未平倉佇列
  const trades = [];     // 完成配對後的交易
  const dailyMap = {};   // key=YYYYMMDD，存淨利

  rows.forEach(row => {
    const [ts, priceStr, action] = row.trim().split(/\s+/);
    if (!action) return;                    // 防呆
    const price = +parseFloat(priceStr);    // 15663.000000 → 15663

    // 建倉
    if (ENTRY.includes(action)) {
      queue.push({ side: action === '新買' ? 'LONG':'SHORT',
                   priceIn: price, tsIn: ts });
      return;
    }

    // 平倉
    const i = queue.findIndex(p =>
         (p.side==='LONG'  && EXIT_LONG .includes(action)) ||
         (p.side==='SHORT' && EXIT_SHORT.includes(action)));
    if (i === -1) return;                   // 找不到對應持倉（資料缺口）
    const pos = queue.splice(i,1)[0];
    const pnlPts = pos.side==='LONG' ? price-pos.priceIn : pos.priceIn-price;
    const pnlNTD = pnlPts * MULTIPLIER;
    const date   = ts.slice(0,8);
    trades.push({ ...pos, tsOut:ts, priceOut:price, pnlNTD, date });
    dailyMap[date] = (dailyMap[date]||0) + pnlNTD;
  });

  render(trades, dailyMap);
}

/* ========= 3. 把統計數字塞回網頁 ========= */
function render(tr, dailyMap) {
  if (!tr.length) return alert('沒有配對成功的交易！');

  // ---- 基本統計 ----
  const ttl   = tr.length;
  const prof  = tr.filter(t=>t.pnlNTD>0);
  const loss  = tr.filter(t=>t.pnlNTD<0);
  const gp    = sum(prof.map(t=>t.pnlNTD));
  const gl    = sum(loss.map(t=>t.pnlNTD));
  const net   = gp + gl;
  const pf    = Math.abs(gl)?(gp/Math.abs(gl)).toFixed(2):'∞';
  const slAdj = net - ttl*MULTIPLIER;       // 每筆滑點 1 點＝200 元

  // ---- 多空統計 ----
  const longT   = tr.filter(t=>t.side==='LONG');
  const shortT  = tr.filter(t=>t.side==='SHORT');
  const longP   = sum(longT .map(t=>t.pnlNTD));
  const shortP  = sum(shortT.map(t=>t.pnlNTD));
  const longWin = longT .filter(t=>t.pnlNTD>0).length;
  const longLoss= longT .length-longWin;
  const shortWin= shortT.filter(t=>t.pnlNTD>0).length;
  const shortLoss=shortT.length-shortWin;

  // ---- 勝率 ----
  const winTrades   = prof.length;
  const lossTrades  = loss.length;
  const winRate     = pct(winTrades, ttl);
  const lossRate    = pct(lossTrades, ttl);
  const longWinRt   = pct(longWin , longT.length);
  const longLossRt  = pct(longLoss, longT.length);
  const shortWinRt  = pct(shortWin, shortT.length);
  const shortLossRt = pct(shortLoss, shortT.length);

  // ---- 單日最大獲利 / 虧損 ----
  const dailyNet = Object.values(dailyMap);
  const maxDaily = Math.max(...dailyNet);
  const minDaily = Math.min(...dailyNet);

  // ---- 寫回 HTML ----
  set('totalTrades'          , ttl);
  set('winningTrades'        , winTrades);
  set('losingTrades'         , lossTrades);
  set('totalProfit'          , net);
  set('slippageAdjustedProfit', slAdj);
  set('overallWinRate'       , winRate);
  set('overallLossRate'      , lossRate);
  set('overallMaxDailyProfit', maxDaily);
  set('overallMaxDailyLoss'  , minDaily);

  set('longTrades'  , longT.length);
  set('longProfit'  , longP);
  set('longWinRate' , longWinRt);
  set('longLossRate', longLossRt);
  set('shortTrades' , shortT.length);
  set('shortProfit' , shortP);
  set('shortWinRate', shortWinRt);
  set('shortLossRate', shortLossRt);

  // ---- 填表格 ----
  const tbody = document.getElementById('dailyStats');
  tbody.innerHTML = '';
  tr.forEach(t=>{
    const r=document.createElement('tr');
    r.innerHTML=`
      <td>${t.tsOut}</td>
      <td>${t.priceOut}</td>
      <td>${t.side==='LONG'?'平賣/強平':'平買/強平'}</td>
      <td>${Math.abs(t.pnlNTD)/MULTIPLIER}</td>
      <td>${t.side==='LONG'?Math.abs(t.pnlNTD)/MULTIPLIER:''}</td>
      <td>${t.side==='SHORT'?Math.abs(t.pnlNTD)/MULTIPLIER:''}</td>
      <td>${t.pnlNTD}</td>
      <td>${dailyMap[t.date]}</td>
      <td><!-- 累積獲利：下方圖表直接呈現 --></td>`;
    tbody.appendChild(r);
  });

  // ---- 畫圖 ----
  drawChart(dailyMap);
}

/* ========= 4. 圖表 ========= */
let chartObj=null;
function drawChart(map) {
  if(chartObj){ chartObj.destroy(); }
  const ctx=document.getElementById('chart');
  const dates = Object.keys(map).sort();
  const cumus = [];
  dates.reduce((acc,d)=>{
    acc += map[d];
    cumus.push(acc);
    return acc;
  },0);

  chartObj=new Chart(ctx,{
    type:'line',
    data:{
      labels:dates,
      datasets:[{
        label:'每日累積結餘',
        data:cumus,
        borderColor:'yellow',
        backgroundColor:'rgba(255,255,0,.1)',
        fill:true
      }]
    },
    options:{
      responsive:true,
      scales:{y:{beginAtZero:false}}
    }
  });
}

/* ========= 5. 小工具 ========= */
const sum = arr => arr.reduce((a,b)=>a+b,0);
const pct = (num,den) => den? (num/den*100).toFixed(2)+'%':'0%';
const set = (id,val)=>{document.getElementById(id).textContent=val.toLocaleString('zh-TW');};
</script>
